<!DOCTYPE html>
<html lang="en">
  
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>Wrapping callbacks without userdata &middot; Planet of the Crabs</title>
    <meta name="description" content="ðŸ¦€ fearless rust" />
    <link rel="shortcut icon"  href="https://kitallis.github.io/hades/favicon.ico" />
    <link rel="alternate" type="application/atom+xml" title="RSS" href="https://kitallis.github.io/hades/atom.xml">

    <style>html,body{background:#fffaf7;color:#2d2d2d;font:16px/1.5 -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"}a,a:visited{color:darkred;text-decoration:none}a:hover{text-decoration:underline}main{margin:auto;max-width:60rem;padding:0.8rem}pre{background:white;overflow:scroll;padding:1rem}td{border:1px solid #2d2d2d;padding:10px}img{height:auto;max-width:100%}.homepage-list{list-style:none;padding:1rem 0}.homepage-list li{align-items:center;display:flex;flex-wrap:wrap;justify-content:space-between;margin-bottom:10px}@media (max-width: 38rem){.homepage-list li a{width:100%}}
</style>

    <meta property="og:site_name" content="Planet of the Crabs">
      
      <meta property="og:title" content="Wrapping callbacks without userdata">
      <meta property="og:description" content="">
      <meta property="og:url" content="https://kitallis.github.io/hades/wrapping-callbacks-without-userdata-swy8fcvzhrsuoswelwag/">
      <meta property="og:image" content="">

      <meta property="og:type" content="article" />
        <meta property="article:published_time" content="2016-07-29T08:08:00-07:00" />

      <link rel="prev" href="https://kitallis.github.io/hades/this-week-in-rust-docs-14-w5ann-zgrrkzljchozgzs/" />
      <link rel="next" href="https://kitallis.github.io/hades/this-week-in-rust-docs-15-tqv4bcybgi4hdrm1ovova/" />
    

  </head>
  

  <body>
    <main id="main" role="main">

      
      <header role="banner">
        <h3 style="margin-top:0;">
          <a href="https://kitallis.github.io/hades/" title="Home">Planet of the Crabs</a>
          <br /><small>ðŸ¦€ fearless rust</small>
        </h3>
      </header>
      <hr />
      

      
<article>
  <h1>Wrapping callbacks without userdata</h1>

  
    <p style="font-size:90%;">
      Posted on <time datetime="2016-07-29T08:08:00-07:00">July 29, 2016</time>
      by <a href="https:&#x2F;&#x2F;www.platymuus.com&#x2F;posts&#x2F;2016&#x2F;callbacks-without-userdata&#x2F;">Platymuus</a>

    </p>
  

  <p>Itâ€™s easy to find articles describing how to wrap Rust closures to pass to C libraries that will carry a <code class="highlighter-rouge">void*</code> to your callback, but what can you do when no userdata value is provided? This post is based on work Iâ€™ve done for the <a href="https://github.com/jcmoyer/rust-lua53"><code class="highlighter-rouge">lua</code> crate</a>.</p>
<h2 id="the-situation">The Situation</h2>
<p>Letâ€™s imagine that the C library provides an API roughly analogous to the following:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">ffi_Object</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span> <span class="c">// opaque type representing foreign Object</span>
<span class="k">type</span> <span class="n">ffi_Callback</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="k">extern</span> <span class="k">fn</span><span class="p">(</span><span class="o">*</span><span class="k">mut</span> <span class="n">ffi_Object</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span><span class="p">;</span>
<span class="k">extern</span> <span class="p">{</span>
	<span class="k">fn</span> <span class="nf">ffi_push_callback</span><span class="p">(</span><span class="n">_</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">ffi_Object</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">ffi_Callback</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>We currently have a safe wrapper type named <code class="highlighter-rouge">Object</code> and we want to enable consumers of our library to push callbacks onto it without writing any <code class="highlighter-rouge">unsafe</code> code, but how can we do that without a userdata pointer? While the lack of a userdata pointer prevents us from carrying any state with the callback (ruling out closures), itâ€™s still possible to wrap ordinary functions.</p>
<h2 id="the-solution">The Solution</h2>
<p>First, letâ€™s think about the signature we want the users of our wrapper to conform to. The FFI demands <code class="highlighter-rouge">unsafe extern fn(*mut ffi_Object) -&gt; u32</code>, but we want to allow such callbacks to be totally safe. This means no <code class="highlighter-rouge">unsafe</code> or <code class="highlighter-rouge">extern</code>, and we should replace <code class="highlighter-rouge">*mut ffi_Object</code> with a safe analogue. Since the callback does not take ownership, this is <code class="highlighter-rouge">&amp;mut Object</code>.</p>
<p>Now weâ€™re going to need to define a function that converts from our safe signature to the unsafe signature. At first, you might try to write:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">wrap_callback</span><span class="p">(</span><span class="n">callback</span><span class="p">:</span> <span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">Object</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">ffi_Callback</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div></div>
<p>but this leads to a dead end. A <code class="highlighter-rouge">fn(&amp;mut Object) -&gt; u32</code> is a function pointer, a runtime value, state! Exactly what we canâ€™t pack into an <code class="highlighter-rouge">ffi_Callback</code>. Weâ€™re going to need to build, at compile time, a different <code class="highlighter-rouge">ffi_Callback</code> for each function weâ€™re ever passed. Luckily, Rust has the useful property that each function gets its own unique type, so we can use a type parameter - our <code class="highlighter-rouge">wrap_callback</code> function is going to be generic. These unique types canâ€™t be written directly, so letâ€™s add a dummy parameter <code class="highlighter-rouge">_: F</code> to allow inference to fill them in for us.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="n">wrap_callback</span><span class="o">&lt;</span><span class="n">F</span><span class="p">:</span> <span class="nf">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">Object</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span><span class="p">:</span> <span class="n">F</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">ffi_Callback</span> <span class="p">{</span>
</code></pre></div></div>
<p>Now that we know the functionâ€™s signature, what about its contents? First, letâ€™s not forget to reintroduce a restriction we just accidentally loosened: this signature accepts closures with state, and itâ€™s not possible for us to support that. Letâ€™s be sure weâ€™re being passed ordinary functions (or equally-valid stateless closures):</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">assert</span><span class="o">!</span><span class="p">(</span><span class="nn">mem</span><span class="p">::</span><span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div></div>
<p>Itâ€™s a little unfortunate that we have to runtime assert this and canâ€™t check it at compile time, but itâ€™s the best we can do in current Rust. Make sure this requirement is displayed in your libraryâ€™s documentation.</p>
<p>Alright, now what? Well, we need to define a function with the signature demanded by <code class="highlighter-rouge">ffi_Callback</code>. Unlike <code class="highlighter-rouge">wrap_callback</code>, which accepts a function as a type parameter and returns an <code class="highlighter-rouge">ffi_Callback</code>, this function will accept the same and <em>be</em> an <code class="highlighter-rouge">ffi_Callback</code>.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">unsafe</span> <span class="k">extern</span> <span class="k">fn</span> <span class="n">wrapped</span><span class="o">&lt;</span><span class="n">F</span><span class="p">:</span> <span class="nf">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">Object</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">ffi_Object</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
</code></pre></div></div>
<p>First, letâ€™s convert our <code class="highlighter-rouge">*mut ffi_Object</code> into a safe <code class="highlighter-rouge">Object</code> we can use:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		<span class="k">let</span> <span class="k">mut</span> <span class="n">object</span> <span class="o">=</span> <span class="nn">Object</span><span class="p">::</span><span class="nf">from_ptr</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
</code></pre></div></div>
<p>Now we need to obtain a value of type <code class="highlighter-rouge">F</code> in order to call it. We just asserted that <code class="highlighter-rouge">F</code> is zero-sized, so thereâ€™s exactly one possible value, but the compiler doesnâ€™t know that. Weâ€™ll have to unsafely construct that value somehow - probably the simplest way is <a href="https://doc.rust-lang.org/std/mem/fn.zeroed.html"><code class="highlighter-rouge">mem::zeroed</code></a>. Then, weâ€™re going to call that function with a reference to the <code class="highlighter-rouge">Object</code>, and save the result:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		<span class="c">//           | generate value ||  call it  |</span>
		<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">mem</span><span class="p">::</span><span class="nn">zeroed</span><span class="p">::</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">()(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">object</span><span class="p">);</span>
</code></pre></div></div>
<p>Lastly, since our <code class="highlighter-rouge">Object</code> is an owned type, we need to avoid dropping it, then return the result we just generated. A future post will cover how to handle this in a less risky way.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		<span class="nn">mem</span><span class="p">::</span><span class="nf">forget</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
		<span class="n">result</span>
	<span class="p">}</span>
</code></pre></div></div>
<p>Now weâ€™re back in <code class="highlighter-rouge">wrap_callback</code>, ready to return the function satisfying <code class="highlighter-rouge">ffi_Closure</code> we just built:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="nn">wrapped</span><span class="p">::</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>And thatâ€™s it! Using it is simple, and as we hoped, contains no use of <code class="highlighter-rouge">unsafe</code>:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">our_callback</span><span class="p">(</span><span class="n">object</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Object</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="k">fn</span> <span class="nf">push_our_callback</span><span class="p">(</span><span class="n">object</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Object</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">let</span> <span class="n">wrapped</span><span class="p">:</span> <span class="n">ffi_Callback</span> <span class="o">=</span> <span class="nf">wrap_callback</span><span class="p">(</span><span class="n">our_callback</span><span class="p">);</span>
	<span class="n">object</span><span class="nf">.push_callback</span><span class="p">(</span><span class="n">wrapped</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Depending on your needs, you can make <code class="highlighter-rouge">wrap_callback</code> public or use it internally.</p>
<h2 id="full-example">Full Example</h2>
<p>Hereâ€™s the code in this article all put together, including a dummy version of <code class="highlighter-rouge">Object</code> which I omitted for brevity. If you want to experiment, you can use this code on the <a href="https://play.rust-lang.org/?gist=62b88ad266c9264f4dcf362a98033e18&amp;version=stable">Rust Playground</a>. Iâ€™m interested in feedback and can accept it by email or the comments section of wherever you found this post.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">#</span><span class="o">!</span><span class="p">[</span><span class="nf">allow</span><span class="p">(</span><span class="n">non_camel_case_types</span><span class="p">)]</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">mem</span><span class="p">;</span>
<p><span class="c">// The Situation</span>
<span class="k">struct</span> <span class="n">ffi_Object</span><span class="p">;</span>
<span class="k">type</span> <span class="n">ffi_Callback</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="k">extern</span> <span class="k">fn</span><span class="p">(</span><span class="o"><em></span><span class="k">mut</span> <span class="n">ffi_Object</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">fn</span> <span class="nf">ffi_push_callback</span><span class="p">(</span><span class="n">_</span><span class="p">:</span> <span class="o"></em></span><span class="k">mut</span> <span class="n">ffi_Object</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">ffi_Callback</span><span class="p">)</span> <span class="p">{}</span></p>
<p><span class="c">// Dummy wrapper</span>
<span class="k">struct</span> <span class="n">Object</span> <span class="p">{</span>
<span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">ffi_Object</span>
<span class="p">}</span></p>
<p><span class="k">impl</span> <span class="n">Object</span> <span class="p">{</span>
<span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Object</span> <span class="p">{</span>
<span class="c">// initialize ffi_Object here</span>
<span class="n">Object</span> <span class="p">{</span> <span class="n">ptr</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">ptr</span><span class="p">::</span><span class="nf">null_mut</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}</span>
<span class="k">fn</span> <span class="nf">from_ptr</span><span class="p">(</span><span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">ffi_Object</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Object</span> <span class="p">{</span>
<span class="n">Object</span> <span class="p">{</span> <span class="n">ptr</span><span class="p">:</span> <span class="n">ptr</span> <span class="p">}</span>
<span class="p">}</span>
<span class="k">fn</span> <span class="nf">push_callback</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">cb</span><span class="p">:</span> <span class="n">ffi_Callback</span><span class="p">)</span> <span class="p">{</span>
<span class="nf">ffi_push_callback</span><span class="p">(</span><span class="k">self</span><span class="py">.ptr</span><span class="p">,</span> <span class="n">cb</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">}</span></p>
<p><span class="k">impl</span> <span class="n">Drop</span> <span class="k">for</span> <span class="n">Object</span> <span class="p">{</span>
<span class="k">fn</span> <span class="k">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
<span class="c">// destroy ffi_Object here</span>
<span class="p">}</span>
<span class="p">}</span></p>
<p><span class="c">// The Solution</span>
<span class="k">fn</span> <span class="n">wrap_callback</span><span class="o">&lt;</span><span class="n">F</span><span class="p">:</span> <span class="nf">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">Object</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span><span class="p">:</span> <span class="n">F</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">ffi_Callback</span> <span class="p">{</span>
<span class="k">assert</span><span class="o">!</span><span class="p">(</span><span class="nn">mem</span><span class="p">::</span><span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span></p>
<pre style="background-color:#2b303b;">
<code>&lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wrapped&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;u32&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ffi_Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;u32&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;from_ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;mem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;transmute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;nn&quot;&gt;mem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;forget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nn&quot;&gt;wrapped&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
</code></pre>
<p><span class="p">}</span></p>
<p><span class="c">// Usage</span>
<span class="k">fn</span> <span class="nf">our_callback</span><span class="p">(</span><span class="n">_</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Object</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
<span class="mi">0</span>
<span class="p">}</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">object</span> <span class="o">=</span> <span class="nn">Object</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
<span class="k">let</span> <span class="n">wrapped</span><span class="p">:</span> <span class="n">ffi_Callback</span> <span class="o">=</span> <span class="nf">wrap_callback</span><span class="p">(</span><span class="n">our_callback</span><span class="p">);</span>
<span class="n">object</span><span class="nf">.push_callback</span><span class="p">(</span><span class="n">wrapped</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div></p>
<h2 id="addendum-safer-less-usable">Addendum: Safer, Less Usable</h2>
<p>If youâ€™re not satisfied with the runtime assert, it can be eliminated if youâ€™re willing to sacrifice usability:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Definition</span>
<span class="k">trait</span> <span class="n">Callback</span> <span class="p">{</span>
	<span class="k">fn</span> <span class="nf">call</span><span class="p">(</span><span class="n">object</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Object</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span><span class="p">;</span>
<span class="p">}</span>
<p><span class="k">fn</span> <span class="n">wrap_callback</span><span class="o">&lt;</span><span class="n">F</span><span class="p">:</span> <span class="n">Callback</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">ffi_Callback</span> <span class="p">{</span>
<span class="k">unsafe</span> <span class="k">extern</span> <span class="k">fn</span> <span class="n">wrapped</span><span class="o">&lt;</span><span class="n">F</span><span class="p">:</span> <span class="n">Callback</span><span class="o">&gt;</span><span class="p">(</span><span class="n">object</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">ffi_Object</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">object</span> <span class="o">=</span> <span class="nn">Object</span><span class="p">::</span><span class="nf">from_ptr</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">F</span><span class="p">::</span><span class="nf">call</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">object</span><span class="p">);</span>
<span class="nn">mem</span><span class="p">::</span><span class="nf">forget</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
<span class="n">result</span>
<span class="p">}</span>
<span class="nn">wrapped</span><span class="p">::</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span>
<span class="p">}</span></p>
<p><span class="c">// Usage</span>
<span class="k">struct</span> <span class="n">OurCallback</span><span class="p">;</span>
<span class="k">impl</span> <span class="n">Callback</span> <span class="k">for</span> <span class="n">OurCallback</span> <span class="p">{</span>
<span class="k">fn</span> <span class="nf">call</span><span class="p">(</span><span class="n">object</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Object</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
<span class="o">...</span>
<span class="p">}</span>
<span class="p">}</span></p>
<p><span class="k">fn</span> <span class="nf">push_our_callback</span><span class="p">(</span><span class="n">object</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Object</span><span class="p">)</span> <span class="p">{</span>
<span class="n">object</span><span class="nf">.push_callback</span><span class="p">(</span><span class="nn">wrap_callback</span><span class="p">::</span><span class="o">&lt;</span><span class="n">OurCallback</span><span class="o">&gt;</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div></p>
<p><em>Thanks to Lalaland on <code class="highlighter-rouge">#rust</code> for this suggestion.</em></p>
<h2 id="addendum-the-past">Addendum: The Past</h2>
<p>There was once a time when those unique per-function types we made use of were not zero-sized! This was just an implementation flaw and has since been resolved, but it was possible to work around it using closures that captured no state, and <em>were</em> zero-sized:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">push_our_callback</span><span class="p">(</span><span class="n">object</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Object</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">object</span><span class="nf">.push_callback</span><span class="p">(</span><span class="nf">wrap_callback</span><span class="p">(|</span><span class="n">s</span><span class="p">|</span> <span class="nf">our_callback</span><span class="p">(</span><span class="n">s</span><span class="p">)));</span>
<span class="p">}</span>
</code></pre></div></div>
</article>


      <nav class="pagination">
        
        
      </nav>

      
      <footer role="contentinfo">
        <hr />
        
        
        <small>Built with <a href="https://www.getzola.org/">Zola</a>.<br />
          Maintained with &hearts; for the web.<br />
          
        </small>
        
      </footer>
      

    </main>
    
    
  </body>
</html>

